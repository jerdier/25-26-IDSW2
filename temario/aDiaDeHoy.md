# A día de hoy deberíamos saber

> *Entiéndase "deberíamos saber" como una combinación de "nos debería sonar", "no nos debería sorprender", "deberíamos conocer", "deberíamos saber manejar", en función del tema abordado. En cualquier caso, lo mínimo es "no nos debería sorprender" y deberíamos poder tener una mínima conversación o lectura sobre estos temas.*

## 18 febrero

- El antipatrón de descomposición funcional: clases-verbo sin estado, síntomas y consecuencias
- Relaciones entre clases por colaboración: composición, agregación, asociación y uso
- Diferencias entre ellas: visibilidad, temporalidad y versatilidad

## 12 febrero

- Qué es el diseño y para qué sirve: análisis vs. diseño, JEDUF vs. BDUF
- Estrategias de clasificación: descripción informal (Abbott), análisis clásico, análisis del dominio, análisis del comportamiento, análisis de casos de uso
- Fortalezas y limitaciones de cada estrategia; que son complementarias, no excluyentes

## 11 febrero

- Las cuatro variables de un proyecto software: ámbito, tiempo, coste y calidad
- La naturaleza del ámbito: por qué es la variable más importante y por qué es inherentemente variable
- Qué es la mantenibilidad y sus tres tipos: correctiva, adaptativa y perfectiva
- Viscosidad, rigidez, fragilidad e inmovilidad como síntomas de mal diseño
- Qué es la crisis del software, sus causas y sus categorías (gestión, requisitos, tecnología)
- Qué es un proceso de desarrollo de software

## 5 febrero

- Qué es el software
- Por qué el software sufre de inefectividad: ámbito, tiempo, coste y calidad como variables interrelacionadas
- El software como sistema complejo: estructura jerárquica, separación de asuntos, patrones comunes
- Abstracción, encapsulación, modularidad y jerarquía como herramientas para dominar la complejidad
- Por qué controlar la complejidad es la esencia de la programación
- KISS, código limpio y simplicidad como principios rectores del diseño
